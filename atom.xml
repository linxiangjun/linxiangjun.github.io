<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Code Charm</title>
  
  <subtitle>Cogito, ergo sum</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.linxiangjun.com/"/>
  <updated>2020-01-07T05:33:41.357Z</updated>
  <id>http://www.linxiangjun.com/</id>
  
  <author>
    <name>linxiangjun</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>如何优雅的使用Web Worker</title>
    <link href="http://www.linxiangjun.com/how-to-use-web-woker-elegently.html"/>
    <id>http://www.linxiangjun.com/how-to-use-web-woker-elegently.html</id>
    <published>2020-01-07T05:31:56.000Z</published>
    <updated>2020-01-07T05:33:41.357Z</updated>
    
    <content type="html"><![CDATA[<p>欢迎star：<a href="https://github.com/linxiangjun/complex-calculations-worker" target="_blank" rel="noopener">complex-calculations-worker</a></p><p><strong>Web Worker</strong>是HTML5中提出的概念，用来处理独立于主线程处理高费时的任务，从而不会阻塞主线程。目前绝大部分浏览器都支持Web Worker功能，不过使用时要注意它不能操纵DOM元素、同源政策等问题。</p><p>Web Worker的使用一般是指定一个脚本的URI来执行worker线程，通过<code>postMessage</code>方法和<code>onmessage</code>事件处理函数来进行数据传递。同时，如果Worker线程与主线程频繁的通信，仍然可能影响页面的性能。对于复杂的计算处理来说，只执行一次的话，也没有必要使得Worker线程一直存在。所以，我才打算开发一个能够通过传递进入的复杂执行函数来自动创建一个Worker线程，同时当运算完成后，返回结果值，最后关闭Worker线程。这样在很多业务场景中都可以方便的使用，用法也很简洁易懂。</p><p>我们最终需要的效果就是传入一个函数，然后自动生成一个Worker线程来处理它，具体的使用方式如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">useWorker(event).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// do something</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>接下来看下如何实现这样一个工具库。</p><p>首先，需要通过传入的函数来生成一个js脚本，我们<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Blob" target="_blank" rel="noopener">Blob</a>对象来创建一个js脚本：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> create = <span class="function"><span class="params">f</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> f === <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> code = [</span><br><span class="line">      <span class="string">`self.fn = <span class="subst">$&#123;f.toString()&#125;</span>;`</span>,</span><br><span class="line">      <span class="string">'self.onmessage = (e) =&gt; &#123;'</span>,</span><br><span class="line">      <span class="string">' const r = self.fn(e.data);'</span>,</span><br><span class="line">      <span class="string">' self.postMessage(r);'</span>,</span><br><span class="line">      <span class="string">'&#125;'</span></span><br><span class="line">    ];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> blob = <span class="keyword">new</span> Blob(code, &#123; <span class="attr">type</span>: <span class="string">'text/javascript'</span> &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再使用<code>URL.createObjectURL()</code>来创建URL的Blob对象，返回一个包含了对象URL的DOMString，它可以直接在Web Worker中使用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> url = URL.createObjectURL(blob);</span><br><span class="line"><span class="keyword">const</span> worker = <span class="keyword">new</span> Worker(url);</span><br></pre></td></tr></table></figure><p>另外，我们需要在worker新增<code>cleanup</code>属性，用来释放URL对象和关闭Worker线程。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">worker.cleanup = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  URL.revokeObjectURL(url);</span><br><span class="line">  worker.terminate();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样，自动创建Worker线程的函数就开发好了，接下来开发一个<code>useWorker</code>方法来调用。这里我们使用Promise来对Worker的交互与错误进行处理。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> useWorker = <span class="function">(<span class="params">f, i</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> worker = create(f);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!worker) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Need correctly parameter!'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  worker.postMessage(i);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    worker.onmessage = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (worker.cleanup) worker.cleanup();</span><br><span class="line">      resolve(e.data);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    worker.onerror = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (worker.cleanup) worker.cleanup();</span><br><span class="line">      reject(e.message);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    worker.onmessageerror = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (worker.cleanup) worker.cleanup();</span><br><span class="line">      reject(e.message);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>最后，我们来测试下：</p><p><strong>不使用Web Worker</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> runTime = <span class="built_in">Date</span>.now();</span><br><span class="line"><span class="built_in">console</span>.log(runTime);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10000000</span>; i++) &#123;</span><br><span class="line"><span class="comment">// do something</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Date</span>.now() - runTime); <span class="comment">// 10 milliseconds or more</span></span><br></pre></td></tr></table></figure><p><strong>使用Web Worker</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> runTime = <span class="built_in">Date</span>.now();</span><br><span class="line"><span class="built_in">console</span>.log(runTime);</span><br><span class="line"></span><br><span class="line">useWorker(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10000000</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'finish'</span>;</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// time</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Date</span>.now() - runTime); <span class="comment">// within 5 milliseconds</span></span><br></pre></td></tr></table></figure><p>可以看到，确实优化了性能。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;欢迎star：&lt;a href=&quot;https://github.com/linxiangjun/complex-calculations-worker&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;complex-calculations-worker&lt;/a
      
    
    </summary>
    
      <category term="开源系列" scheme="http://www.linxiangjun.com/categories/%E5%BC%80%E6%BA%90%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="开源系列" scheme="http://www.linxiangjun.com/tags/%E5%BC%80%E6%BA%90%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>React Hooks技术最佳实践（二）</title>
    <link href="http://www.linxiangjun.com/react-hooks-best-practices-2.html"/>
    <id>http://www.linxiangjun.com/react-hooks-best-practices-2.html</id>
    <published>2019-11-07T05:08:00.000Z</published>
    <updated>2019-11-07T05:10:02.271Z</updated>
    
    <content type="html"><![CDATA[<h2 id="useEffect"><a href="#useEffect" class="headerlink" title="useEffect"></a>useEffect</h2><p><code>useEffect</code>是除<code>useState</code>之外使用最常用的Hooks之一，它可以用来管理副作用，替代传统class组件中的<code>componentDidMount</code>和<code>componentWillUnmount</code>方法或是根据依赖项来执行代码。</p><p><code>useEffect</code>的用法并不复杂，但是如果对于它的执行过程和机制不熟悉的话，还是很容易出现死循环、依赖运算错误等问题。同时，它每次运行都相当于对当前的状态存储了一份快照，这就这意味在它当中执行<code>setTimeout</code>获取到的都不是最新的状态，而是运行时的状态。想要更加深入了解的推荐阅读<a href="https://overreacted.io/zh-hans/a-complete-guide-to-useeffect/" target="_blank" rel="noopener">useEffect 完整指南</a>。</p><p>本文章属于<strong>React Hooks技术最佳实践</strong>的第二篇文章，第一篇介绍了<code>useState</code>的最佳实践，感兴趣的朋友可以阅读<a href="https://www.linxiangjun.com/react-hooks-best-practices-1.html">React Hooks技术最佳实践（一）</a>。</p><h3 id="替代componentDidMount"><a href="#替代componentDidMount" class="headerlink" title="替代componentDidMount"></a>替代componentDidMount</h3><p>通过设置<code>useEffect</code>的第二个依赖参数为<code>[]</code>可以替代<code>componentDidMount</code>，虽然它们的执行时机不是完全一致的。这样我们就可以在<code>useEffect</code>中处理需要在组件挂载后的操作或者异步请求，它能够获取到<code>state</code>。因为依赖项为<code>[]</code>，所以在整个组件生命周期中只会在挂载时运行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 在组件挂载后处理事务或副作用</span></span><br><span class="line">  <span class="comment">// 能够获取到state</span></span><br><span class="line">&#125;, [])</span><br></pre></td></tr></table></figure><h3 id="副作用"><a href="#副作用" class="headerlink" title="副作用"></a>副作用</h3><p>先来看看如何正确的使用<code>async</code>方法。</p><p><strong>错误的示范</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">useEffect(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; data, result &#125; = <span class="keyword">await</span> asyncRequest();</span><br><span class="line">&#125;, [])</span><br></pre></td></tr></table></figure><p><code>useEffect</code>并不建议你在回调函数中直接使用<code>async</code>，这样使用会直接触发报错，通常如果安装了相关lint的话会有提示。因为这么使用会导致回调函数相互之间产生竞争状态，而Effect回调函数应该是同步的。</p><p><strong>推荐的做法</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> requestFn = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; data, result &#125; = <span class="keyword">await</span> asyncRequest();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  requestFn();</span><br><span class="line">&#125;, [])</span><br></pre></td></tr></table></figure><p>如果需要在获取异步数据之后更新<code>state</code>，也可以在<code>requestFn</code>函数中处理。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [value, updateValue] = useState();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> requestFn = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; data, result &#125; = <span class="keyword">await</span> asyncRequest();</span><br><span class="line">  updateValue(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  requestFn();</span><br><span class="line">&#125;, [])</span><br></pre></td></tr></table></figure><p>如果异步请求依赖任何的<code>state</code>，则需要清晰的写在<code>useEffect</code>的依赖项中，这样每次在<code>state</code>改变之后都会执行异步请求。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> requestFn = <span class="keyword">async</span> (param) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; data, result &#125; = <span class="keyword">await</span> asyncRequest(param);</span><br><span class="line">  updateValue(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  requestFn(param);</span><br><span class="line">&#125;, [param])</span><br></pre></td></tr></table></figure><h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><h4 id="正确的使用"><a href="#正确的使用" class="headerlink" title="正确的使用"></a>正确的使用</h4><p>我们知道每次<code>state</code>或者<code>props</code>改变都会导致组件的re-render，所以<code>useEffect</code>在没有任何依赖项时每次都会执行一遍。这时如果在它当中改变了<code>state</code>，那么就会导致死循环。过程就是执行<code>useEffect</code>改变了<code>state</code>，而改变<code>state</code>又导致了重复执行<code>useEffect</code>。</p><p><strong>错误的写法</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [count, updateCount] = useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  updateCount(<span class="function"><span class="params">prevCount</span> =&gt;</span> prevCount++);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>正确的写法一</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [count, updateCount] = useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 增加前置条件，满足时才执行更新状态</span></span><br><span class="line">useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (count &lt; <span class="number">1</span>) &#123;</span><br><span class="line">    updateCount(<span class="function"><span class="params">prevCount</span> =&gt;</span> prevCount++);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>正确的写法二</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [count, updateCount] = useState(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">const</span> [num, updateNum] = useState(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 依赖num，每次num改变后才会执行Effect</span></span><br><span class="line">useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  updateCount(<span class="function"><span class="params">prevCount</span> =&gt;</span> prevCount+num);</span><br><span class="line">&#125;, [num])</span><br></pre></td></tr></table></figure><h4 id="依赖函数"><a href="#依赖函数" class="headerlink" title="依赖函数"></a>依赖函数</h4><p>除了使用<code>state</code>、<code>props</code>作为依赖项，函数也是可以直接作为依赖项使用。不过由于函数每次在组件渲染时都会重新执行，所以Effect会没必要的重复执行。</p><p>不过可以使用<code>useCallback</code>方法来避免这种情况。</p><p><strong>每次渲染都重复执行Effect</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> doSomething = <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// do somethings</span></span><br><span class="line">&#125;, [doSomething])</span><br></pre></td></tr></table></figure><p><strong>使用useCallback</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> doSomething = <span class="function"><span class="params">()</span> =&gt;</span> useCallback(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;, [])</span><br><span class="line"></span><br><span class="line">useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// do somethings once</span></span><br><span class="line">&#125;, [doSomething])</span><br></pre></td></tr></table></figure><p>如果函数依赖任何其他的状态执行，则可以将依赖加入到<code>useCallback</code>的依赖数组项中，这样在依赖项改变后函数都会重新执行，Effect由于依赖了函数，所以Effect也会执行。</p><h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><p>正确的使用Effect的依赖是非常重要的，每次依赖改变后都会使用<code>Object.is</code>方法来比较，如果不同，则执行Effect。所以我们可以通过Memoization技术来优化，具体来说就是每次状态改变后都会与之前记忆的状态作对比，如果值发生了改变，则返回新的状态，并记忆，如果值没有改变，只是引用变了，则返回记忆的状态。这样Effect只在值改变后才执行。</p><p>这一部分在之前的文章中有介绍，这里就不具体展开了。</p><p><a href="https://www.linxiangjun.com/memoization-in-react.html">Memoization技术在React中的应用</a></p><h2 id="useLayoutEffect"><a href="#useLayoutEffect" class="headerlink" title="useLayoutEffect"></a>useLayoutEffect</h2><p>大多数情况下使用<code>useEffect</code>即可，不过当你需要在<code>useEffect</code>中操作DOM时，为了优化渲染效果，可以使用<code>useLayoutEffect</code>。它会在DOM更新完成之后再执行，同时可以读取到DOM布局并同步触发渲染，之后浏览器才进行绘制。</p><p>下一篇介绍其他的Hooks的用法与技巧。</p><p>官方的<a href="https://zh-hans.reactjs.org/docs/hooks-faq.html" target="_blank" rel="noopener">FAQ</a>其实写的很不错，很多陷阱和技巧都介绍了，推荐阅读。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ol><li><a href="https://overreacted.io/zh-hans/a-complete-guide-to-useeffect/" target="_blank" rel="noopener">useEffect 完整指南</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;useEffect&quot;&gt;&lt;a href=&quot;#useEffect&quot; class=&quot;headerlink&quot; title=&quot;useEffect&quot;&gt;&lt;/a&gt;useEffect&lt;/h2&gt;&lt;p&gt;&lt;code&gt;useEffect&lt;/code&gt;是除&lt;code&gt;useState&lt;/co
      
    
    </summary>
    
      <category term="React" scheme="http://www.linxiangjun.com/categories/React/"/>
    
    
      <category term="React" scheme="http://www.linxiangjun.com/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>React Hooks技术最佳实践（一）</title>
    <link href="http://www.linxiangjun.com/react-hooks-best-practices-1.html"/>
    <id>http://www.linxiangjun.com/react-hooks-best-practices-1.html</id>
    <published>2019-10-15T02:12:14.000Z</published>
    <updated>2019-10-15T02:14:43.237Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>React 16.8版本发布于2019年2月6号，它带来了Hooks特性，能够让我们不编写class的情况下也能使用state以及其他的React特性。一个新技术的诞生必然会影响原来的思维模式，在最初的应用中也会碰见很多意想不到的场景和陷阱，这就需要我们在使用他们前清楚的知道哪里可能会有潜在的问题，有哪些更加完善的写法，这也是写本文章的初衷。我们团队在7月份开始在新项目中全面使用Hooks技术，期间也遇到和解决了很多的麻烦和问题，同时让我们对于函数式组件有了更深的理解。</p><p>在本文开始前，需要你掌握React官方中关于<a href="https://zh-hans.reactjs.org/docs/hooks-intro.html" target="_blank" rel="noopener">React Hooks</a>的基础知识。很多坑在官方的<a href="https://zh-hans.reactjs.org/docs/hooks-faq.html" target="_blank" rel="noopener">FAQ</a>已经说明了，经常阅读官方文档也是个良好的习惯。</p><p>本文介绍的是我在使用Hooks的过程中遇见的问题和技巧，可能还有其他我没发现的或者没有写出来的，欢迎和我交流，希望通过阅读本文能够让你快速的掌握Hooks的陷阱和技巧，开发出高质量的函数式组件。那我们就先从<code>useState</code>开始。</p><h2 id="useState"><a href="#useState" class="headerlink" title="useState"></a>useState</h2><p>在Class Component中，使用state来存储组件的状态，用<code>setState</code>来更新，在Hooks中提供了<code>useState</code>API来创建一个state。</p><h3 id="state结构"><a href="#state结构" class="headerlink" title="state结构"></a>state结构</h3><p><code>useState</code>接收一个initialState，同时返回一个state以及更新state的函数。initialState可以使用基础数据类型，也可以使用数组、对象等引用数据类型。这里建议根据state的关联度和作用来决定是否使用多个<code>useState</code>来定义state。</p><p>在下面的例子中，我们根据后端接口返回的数据<code>{data: [Tom, Jerry], total: 2, result: true}</code>来设置state数据。第一种写法直接将所有的请求参数和返回数据全部存储到一个<code>userState</code>中，我们来分析下为何不推荐这么做。</p><p>首先，返回的数据中存在不需要存储在state中的数据字段result。其次，将data与requestParams放在一个state中看似简单，只需要维护一个<code>userState</code>，但是如果需要在<code>useEffect</code>中依赖<code>data</code>或者<code>requestParams</code>将会非常的麻烦，而且每次获取后端返回的数据都将需要一同更新<code>requestParams</code>。</p><p><strong>不建议的写法</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [userState, setUserState] = useState(&#123;</span><br><span class="line">    data: [],</span><br><span class="line">    total: <span class="number">0</span>,</span><br><span class="line">    requestParams: &#123; <span class="attr">id</span>: <span class="number">1</span> &#125;,</span><br><span class="line">    result: <span class="literal">true</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>推荐的写法</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [userData, setUserData] = useState(&#123; <span class="attr">data</span>: [], <span class="attr">total</span>: <span class="number">0</span> &#125;)</span><br><span class="line"><span class="keyword">const</span> [userParams, setUserParams] = useState(&#123; <span class="attr">id</span>: <span class="number">1</span> &#125;)</span><br></pre></td></tr></table></figure><h3 id="避免重复计算"><a href="#避免重复计算" class="headerlink" title="避免重复计算"></a>避免重复计算</h3><p>如果initialState为函数，则<code>useState</code>在初始化时会立刻执行该函数和获取函数的返回值，在没有任何返回值得情况下为<code>undefined</code>。这里需要注意的是每次组件re-render都会导致<code>useState</code>中的函数重新计算，这里可以使用闭包函数来解决问题。在优化后只有组件初始化时才会执行一遍<code>loop</code>函数。</p><p>本例子可以在<a href="https://codesandbox.io/s/gracious-stallman-j3zuw?fontsize=14" target="_blank" rel="noopener">CodeSandbox</a>中查看</p><p><strong>优化前</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> loop = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"calc!"</span>);</span><br><span class="line">  <span class="keyword">let</span> res = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = <span class="number">1000</span>; i &lt; len; i++) &#123;</span><br><span class="line">    res += i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> [value, setValue] = useState(loop());</span><br></pre></td></tr></table></figure><p><strong>优化后</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> App = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [value, setValue] = useState(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> loop();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="更新state"><a href="#更新state" class="headerlink" title="更新state"></a>更新state</h3><p>在某些情况下如果需要从上一个state来计算当前的state，可能会想到使用下面优化前的方法。但是，需要注意的一点是在某些闭包的场景下面<code>count</code>可能不是最新的，这样会导致计算错误。这里推荐使用官方给出的方法。</p><p><strong>优化前</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;+&lt;/button&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优化后</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> &lt;button onClick=&#123;() =&gt; setCount(prevCount =&gt; prevCount + 1)&#125;&gt;+&lt;/button&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下一篇文章介绍<code>useEffect</code>和<code>useLayoutEffect</code>的使用技巧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;React 16.8版本发布于2019年2月6号，它带来了Hooks特性，能够让我们不编写class的情况下也能使用state以及其他的Re
      
    
    </summary>
    
      <category term="React" scheme="http://www.linxiangjun.com/categories/React/"/>
    
    
      <category term="React" scheme="http://www.linxiangjun.com/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>Memoization技术在React中的应用</title>
    <link href="http://www.linxiangjun.com/memoization-in-react.html"/>
    <id>http://www.linxiangjun.com/memoization-in-react.html</id>
    <published>2019-09-26T12:35:42.000Z</published>
    <updated>2019-09-26T12:57:30.567Z</updated>
    
    <content type="html"><![CDATA[<p>最近在研究React Hook优化时，发现<strong>Memoization</strong>技术被官方广泛的使用，比如<code>useCallback</code>和<code>useMemo</code>这两个API，分别用来返回函数的memoized版本和memoized值。<strong>Memoization</strong>其实并不是什么新技术，只是一种优化技巧，维基百科对<strong>Memoization</strong>的定义为：</p><blockquote><p>In computing, memoization or memoisation is an optimization technique used primarily to speed up computer programs by storing the results of expensive function calls and returning the cached result when the same inputs occur again.</p></blockquote><p>简单来说<strong>Memoization</strong>就是存储前一个值，然后每次更新时都将新传入的值和存储的值作比较，然后根据比较结果是否相同来返回存储的值还是新的值。React中使用该技术主要是为了避免不必要的重复渲染。</p><h2 id="在Redux中的应用"><a href="#在Redux中的应用" class="headerlink" title="在Redux中的应用"></a>在Redux中的应用</h2><p>我们用来优化Redux数据的<a href="https://github.com/reduxjs/reselect" target="_blank" rel="noopener">reselect</a>其实就使用了Memoization技术，这篇<a href="https://www.linxiangjun.com/2019/09/03/reselect-source-code/#createSelector">文章</a>分析了reselect源码，可以学习reselect是如果使用该技术来优化Redux数据的。</p><h2 id="在React-Hook中的应用"><a href="#在React-Hook中的应用" class="headerlink" title="在React Hook中的应用"></a>在React Hook中的应用</h2><p>熟悉了<strong>Memoization</strong>定义后，我们看下如果在实战中使用这个技术。在React Hook中，<code>useEffect</code>方法可以使用该技术来优化组件的渲染。本例子可以在<a href="https://codesandbox.io/s/useeffect-zkl36?fontsize=14" target="_blank" rel="noopener">CodeSandbox</a>中查看:smile:。</p><p>我们知道<code>useEffect</code>的第二个数组参数作为effect依赖存在，如果依赖数组发生改变，那么<code>useEffect</code>就会重新执行。<code>useEffect</code>使用<code>===</code>来比较数组参数是否相等，使用<code>Object.assign</code>或者<code>splice</code>这类会操作时会返回新的堆来存储引用值，就会导致值本身没有变化却会重复执行<code>useEffect</code>方法。为了避免这种情况的发生，我们来看下该如果来做。</p><p>首先，先来介绍下<code>useRef</code>方法，这个方法和原来的<code>createRef</code>非常的相似，都是创建一个可变的<code>ref</code>对象。在函数组件中，因为<code>ref</code>对象在组件的整个生命周期内保持不变，所以我们可以用它来存储不会被组件re-render影响的值。所以，在下面的函数中，我们使用<code>ref</code>对象来存储<code>useEffect</code>中传入的第二个数组参数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useRef &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; isEqual &#125; <span class="keyword">from</span> <span class="string">"lodash"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useDeepCompareMemoize</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> ref = useRef();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!isEqual(value, ref.current)) &#123;</span><br><span class="line">    ref.current = value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ref.current;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到我使用了lodash中的深比较方法<code>isEqual</code>来对比两个值，这个可以根据需求自定义方法也可以。</p><p>接下来编写自定义Hook来使用<code>useEffect</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useDeepCompareEffect</span>(<span class="params">callback, dependencies</span>) </span>&#123;</span><br><span class="line">  useEffect(callback, useDeepCompareMemoize(dependencies));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> useDeepCompareEffect;</span><br></pre></td></tr></table></figure><p>然后使用<code>useDeepCompareEffect</code>代替<code>useEffect</code>即可。</p><p>使用的完整代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState, useEffect, useRef &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">"react-dom"</span>;</span><br><span class="line"><span class="keyword">import</span> useDeepCompareEffect <span class="keyword">from</span> <span class="string">"./useDeepCompareEffect.js"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"./styles.css"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> tomCat = &#123;</span><br><span class="line">  name: <span class="string">"Tom"</span>,</span><br><span class="line">  race: <span class="string">"cat"</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> jerryMouse = &#123;</span><br><span class="line">  name: <span class="string">"Jerry"</span>,</span><br><span class="line">  race: <span class="string">"mouse"</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [character, updateCharacter] = useState(tomCat);</span><br><span class="line">  <span class="keyword">const</span> effectCount = useRef(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> deepCompareEffectCount = useRef(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    effectCount.current++;</span><br><span class="line">  &#125;, [character]);</span><br><span class="line"></span><br><span class="line">  useDeepCompareEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    deepCompareEffectCount.current++;</span><br><span class="line">  &#125;, [character]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> changeStar = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> star = character.name === <span class="string">"Tom"</span> ? jerryMouse : tomCat;</span><br><span class="line">    updateCharacter(star);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> assignObj = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    updateCharacter(<span class="built_in">Object</span>.assign(&#123;&#125;, character));</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">"App"</span>&gt;</span><br><span class="line">      &lt;p&gt;Hello, useEffect&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;p className="star"&gt;</span></span><br><span class="line"><span class="regexp">        &#123;character.name&#125; &#123;character.race&#125; &#123;character.friend&#125;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>p&gt;</span><br><span class="line">      &lt;p&gt;useEffect count = &#123;effectCount.current&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;p&gt;deepCompareEffectCount count = &#123;deepCompareEffectCount.current&#125;&lt;/</span>p&gt;</span><br><span class="line">      &lt;p&gt;</span><br><span class="line">        &lt;button onClick=&#123;changeStar&#125;&gt;Change star&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>p&gt;</span><br><span class="line">      &lt;p&gt;</span><br><span class="line">        &lt;button onClick=&#123;assignObj&#125;&gt;Click&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>p&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">const rootElement = document.getElementById("root");</span></span><br><span class="line"><span class="regexp">ReactDOM.render(&lt;App /</span>&gt;, rootElement);</span><br></pre></td></tr></table></figure><p>同样的，点击Click按钮，使用<code>useEffect</code>方法每次都会执行，而使用<code>useDeepCompareEffect</code>的只会执行一次。不过需要注意的是，该优化并不是万金油，而是要根据情况来使用。因为深比较本来就会对性能造成一定的损耗，所以要按需使用。比如<code>useCallback</code>和<code>useMemo</code>最好在需要重复计算时才使用，在其他场景应用不当可能会有副作用，关于这一块的内容推荐阅读本文末尾中的参考文章。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://github.com/kentcdodds/use-deep-compare-effect" target="_blank" rel="noopener">use-deep-compare-effect</a></li><li><a href="https://github.com/alexreardon/memoize-one" target="_blank" rel="noopener">memoize-one</a></li><li><a href="https://blog.logrocket.com/rethinking-hooks-memoization/?from=singlemessage&isappinstalled=0" target="_blank" rel="noopener">You’re overusing useMemo: Rethinking Hooks memoization</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近在研究React Hook优化时，发现&lt;strong&gt;Memoization&lt;/strong&gt;技术被官方广泛的使用，比如&lt;code&gt;useCallback&lt;/code&gt;和&lt;code&gt;useMemo&lt;/code&gt;这两个API，分别用来返回函数的memoized版本和mem
      
    
    </summary>
    
      <category term="React" scheme="http://www.linxiangjun.com/categories/React/"/>
    
    
      <category term="React" scheme="http://www.linxiangjun.com/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>使用React Hook实现Redux状态机</title>
    <link href="http://www.linxiangjun.com/react-hook-acheieve-redux.html"/>
    <id>http://www.linxiangjun.com/react-hook-acheieve-redux.html</id>
    <published>2019-09-13T10:59:48.000Z</published>
    <updated>2019-09-13T11:05:54.968Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Redux is a predictable state container for JavaScript apps.</p></blockquote><p>本文的代码可以在<a href="https://codesandbox.io/embed/usereducer-4w77g" target="_blank" rel="noopener">CodeSandbox</a>中查看。</p><p>Redux是React经常用到的一个数据状态管理器（状态机），它将应用中所有的数据（state）以对象树的形式存储在<em>store</em>中，通过触发<em>action</em>来改变<em>state</em>，而描绘改变规则需要编写<em>reducer</em>。</p><p>因为Redux不仅仅是为React编写的，所以在React中常常会用到<a href="https://github.com/reduxjs/react-redux" target="_blank" rel="noopener">React-Redux</a>来一同使用。React-Redux使用两个主要的API，分为叫做<code>Provider</code>和<code>connect</code>来提升Redux开发效率和体验。</p><p>在React 16.8之前，为了实现统一的状态机，最好的方法就是使用Redux了。不过，React 16.8中Hook API新增的<code>useContext</code>和<code>useReducer</code>能够让我们自己实现一个具备Redux核心功能的状态机。</p><p>我们先看一下Redux的<a href="https://redux.js.org/introduction/three-principles" target="_blank" rel="noopener">三个基本原则</a>是什么：</p><ol><li><strong>单一数据源</strong> - 整个应用程序的state存储在单个store的对象树中</li><li><strong>state为只读</strong> - 改变state的唯一方法是触发一个action</li><li><strong>使用纯函数来修改</strong> - 为了描述actions是如何修改state，你需要编写reducers</li></ol><p>我们遵循这三个基本原则来开发我们自己的状态机，其实查看<code>useReducer</code>的用法就知道它已经满足了原则2和3</p><p><code>const [state, dispatch] = useReducer(reducer, initialArg, init);</code></p><p>所以，我们结合官网的<a href="https://zh-hans.reactjs.org/docs/hooks-reference.html#usereducer" target="_blank" rel="noopener">例子</a>来编写<em>state</em>和<em>reducer</em>。</p><p>文件目录如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public</span><br><span class="line">src</span><br><span class="line">  reducer</span><br><span class="line">    index.js</span><br><span class="line">  index.js</span><br><span class="line">  style.css</span><br><span class="line">package.json</span><br></pre></td></tr></table></figure><p>在reducer文件夹的index.js文件中，编写<code>initialState</code>和<code>reducer</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> initialState = &#123; <span class="attr">count</span>: <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">reducer</span>(<span class="params">state, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"increment"</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">count</span>: state.count + <span class="number">1</span> &#125;;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"decrement"</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">count</span>: state.count - <span class="number">1</span> &#125;;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在src/index.js中生成一个<code>store</code>，只在顶层组件中创建一个<code>store</code>是为了符合原则1。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; reducer, initialState &#125; <span class="keyword">from</span> <span class="string">"./reducer"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = useReducer(reducer, initialState);</span><br></pre></td></tr></table></figure><p>可以看到应用<code>useReducer</code>很简单的就创建了一个符合Redux三个基本原则的状态机，然后我们就要考虑如何将store状态传递到更深层次的组件中。在Redux中我们使用<code>subscribe</code>方法去订阅状态，而使用React-Redux可以将<code>store</code>像props一样传值给子组件，这样就不需要每次都去订阅。所以，接下来我们使用React中的<a href="https://zh-hans.reactjs.org/docs/context.html" target="_blank" rel="noopener">Context</a> API来实现状态的传递。</p><p>在src/index.js中创建一个<code>AppContext</code>，初始值为空：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> AppContext = createContext(&#123;&#125;);</span><br><span class="line"><span class="keyword">const</span> &#123; Provider &#125; = AppContext;</span><br></pre></td></tr></table></figure><p>然后在顶层组件<code>App</code>中使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> store = useReducer(reducer, initialState);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Provider value=&#123;store&#125;&gt;</span><br><span class="line">      &lt;div className=<span class="string">"App"</span>&gt;</span><br><span class="line">        &lt;TopNavBar /&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>Provider&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样无论多深的组件都能够获取到<code>store</code>存储的数据状态，而且能够获取到<code>dispatch</code>方法来改变<code>state</code>。这里React的另一个Hook就要发挥实力了，那就是<code>useContext</code>，它可以接收一个context对象（React.createContext的返回值）并返回该context的当前值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">TopNavBar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> value = useContext(AppContext);</span><br><span class="line">  <span class="keyword">const</span> [state] = value; <span class="comment">// 这里的value就是useReducer创建的store</span></span><br><span class="line">  <span class="keyword">const</span> &#123; count &#125; = state;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;p&gt;&#123;count&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;Button /</span>&gt;</span><br><span class="line">    &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>在<code>Button</code>组件中使用<code>useContext</code>获取<code>dispatch</code>来通过触发一个<code>action</code>来改变<code>count</code>的值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Button</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> value = useContext(AppContext);</span><br><span class="line">  <span class="keyword">const</span> [state, dispatch] = value;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">"button-wrapper"</span>&gt;</span><br><span class="line">      &lt;button type=<span class="string">"button"</span> onClick=&#123;() =&gt; dispatch(&#123; <span class="attr">type</span>: <span class="string">"increment"</span> &#125;)&#125;&gt;</span><br><span class="line">        Plus</span><br><span class="line">      &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button type="button" onClick=&#123;() =&gt; dispatch(&#123; type: "decrement" &#125;)&#125;&gt;</span></span><br><span class="line"><span class="regexp">        Minus</span></span><br><span class="line"><span class="regexp">      &lt;/</span>button&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>这样一个满足Redux的三个原则，同时具备React-Redux部分功能的简洁版状态机就完成了。在一些不需要管理过多复杂状态的应用中我们就可以使用这样的方式来自己创建状态机，当然，我们还有像<em>effect</em>、<em>connect</em>和<em>middleware</em>这样的功能没有完全实现，但是在准备使用他们之前，先得思考以下，是否真的需要。</p><blockquote><p>Brevity is the soul of wisdom. Tediousness is the limbs and outward flourishes.</p><p>—— William Shakespeare</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;Redux is a predictable state container for JavaScript apps.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本文的代码可以在&lt;a href=&quot;https://codesandbox.io/emb
      
    
    </summary>
    
      <category term="React" scheme="http://www.linxiangjun.com/categories/React/"/>
    
    
      <category term="React" scheme="http://www.linxiangjun.com/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>Reselect源码解析</title>
    <link href="http://www.linxiangjun.com/reselect-source-code.html"/>
    <id>http://www.linxiangjun.com/reselect-source-code.html</id>
    <published>2019-09-03T13:42:46.000Z</published>
    <updated>2019-09-05T11:43:26.944Z</updated>
    
    <content type="html"><![CDATA[<p>Reselect主要为Redux的state数据提供了Memoize功能。它能够计算数据，传递最少且必要的state值；具有高性能，只在传递值改变时才会重新计算；具有可组合性，可以将它作为参数传递给其他selectors执行。</p><p>下面是个最基础的使用方式，可以跳转<a href="https://codepen.io/linxiangjun/pen/rNBGKNd?editors=0012" target="_blank" rel="noopener">codepen</a>来运行栗子</p><img src="/reselect-source-code/Reselect-20190903001.png" title="基础用法"><h2 id="createSelector"><a href="#createSelector" class="headerlink" title="createSelector"></a>createSelector</h2><p><code>createSelector</code>方法是Reselect的核心方法，最后一个参数默认为回调函数，其他参数可以为state、selector或数组，其中回调函数会引用其他参数作为自己的参数调用。</p><p><code>createSelector</code>实际上调用的是Reselect中叫做<code>createSelectorCreator</code>的API，该API允许我们开发定制版本的<code>createSelector</code>。</p><p><code>createSelectorCreator</code>被调用时会引用默认的Memoize方法来校验输入数据，在源码中叫做<code>defaultMemoize</code>，该方法返回的函数就是用来判断是直接返回已经记忆的计算结果还是重新计算并返回新的结果。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// func就是createSelector参数中最后一个函数参数</span></span><br><span class="line"><span class="comment">// equalityCheck参数默认获取defaultEqualityCheck方法</span></span><br><span class="line"><span class="comment">// defaultEqualityCheck代码就是判断是否全等的函数：(a, b) =&gt; a === b</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">defaultMemoize</span>(<span class="params">func, equalityCheck = defaultEqualityCheck</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> lastArgs = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">let</span> lastResult = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 比较旧的和新的state是否全等</span></span><br><span class="line">    <span class="comment">// 如果不相等，则重新计算并将结果赋值给lastResult</span></span><br><span class="line">    <span class="keyword">if</span> (!areArgumentsShallowlyEqual(equalityCheck, lastArgs, <span class="built_in">arguments</span>)) &#123;</span><br><span class="line">      lastResult = func.apply(<span class="literal">null</span>, <span class="built_in">arguments</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    lastArgs = <span class="built_in">arguments</span></span><br><span class="line">    <span class="keyword">return</span> lastResult</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中的<code>areArgumentsShallowlyEqual</code>方法思路很简洁，使用for循环依次比较传入的两个数组中的每一个值是否全等。</p><p>我们接下来看一下<code>createSelectorCreator</code>的代码是如何使用<code>defaultMemoize</code>的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// memoize默认为上面介绍的defaultMemoize</span></span><br><span class="line"><span class="comment">// memoizeOptions作为memoize方法的引用参数</span></span><br><span class="line"><span class="comment">// 如果没有传值则默认为equalityCheck = defaultEqualityCheck</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createSelectorCreator</span>(<span class="params">memoize, ...memoizeOptions</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">...funcs</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 统计计算次数</span></span><br><span class="line">    <span class="keyword">let</span> recomputations = <span class="number">0</span></span><br><span class="line">    <span class="comment">// 获取selector参数中的最后一个回调函数</span></span><br><span class="line">    <span class="keyword">const</span> resultFunc = funcs.pop()</span><br><span class="line">    <span class="comment">// getDependencies函数获取其余的参数 先判断第一个参数是否为数组</span></span><br><span class="line">    <span class="comment">// 如果是则返回第一个数组 否则直接返回</span></span><br><span class="line">    <span class="comment">// 注意：参数中具体的项必须为函数类型，否则会抛出一个错误</span></span><br><span class="line">    <span class="keyword">const</span> dependencies = getDependencies(funcs)</span><br><span class="line">    <span class="comment">// 根据传入的arguments来判断是否重新计算结果</span></span><br><span class="line">    <span class="keyword">const</span> memoizedResultFunc = memoize(</span><br><span class="line">      <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        recomputations++</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> resultFunc.apply(<span class="literal">null</span>, <span class="built_in">arguments</span>)</span><br><span class="line">      &#125;,</span><br><span class="line">      ...memoizeOptions</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据传入的state是否改变来判断需不需要执行下面代码</span></span><br><span class="line">    <span class="keyword">const</span> selector = memoize(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">const</span> params = []</span><br><span class="line">      <span class="keyword">const</span> length = dependencies.length</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        params.push(dependencies[i].apply(<span class="literal">null</span>, <span class="built_in">arguments</span>))</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> memoizedResultFunc.apply(<span class="literal">null</span>, params)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    selector.resultFunc = resultFunc</span><br><span class="line">    selector.dependencies = dependencies</span><br><span class="line">    selector.recomputations = <span class="function"><span class="params">()</span> =&gt;</span> recomputations</span><br><span class="line">    selector.resetRecomputations = <span class="function"><span class="params">()</span> =&gt;</span> recomputations = <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> selector</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Reselect的源码很精简，阅读后能够提升对于Memoization和React优化的理解。作者在注释中多次说明使用<code>for</code>代替<code>forEach</code>和<code>every</code>，使用<code>arguments</code>而不是展开运算符是为了更快和提高性能。Reselect的官方文档阅读起来也非常的清晰和轻松，对于常见问题的解答也是很全面，这点要点赞。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Reselect主要为Redux的state数据提供了Memoize功能。它能够计算数据，传递最少且必要的state值；具有高性能，只在传递值改变时才会重新计算；具有可组合性，可以将它作为参数传递给其他selectors执行。&lt;/p&gt;
&lt;p&gt;下面是个最基础的使用方式，可以跳
      
    
    </summary>
    
      <category term="源码系列" scheme="http://www.linxiangjun.com/categories/%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="源码系列" scheme="http://www.linxiangjun.com/tags/%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
</feed>
