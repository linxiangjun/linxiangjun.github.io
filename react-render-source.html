<!DOCTYPE html><html lang="en"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="react渲染原理分析"><meta name="keywords" content="React"><meta name="author" content="linxiangjun"><meta name="copyright" content="linxiangjun"><title>react渲染原理分析 | Code Charm</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#前言"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JSX"><span class="toc-number">2.</span> <span class="toc-text">JSX</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#createElement"><span class="toc-number">3.</span> <span class="toc-text">createElement</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ReactDOM-render"><span class="toc-number">4.</span> <span class="toc-text">ReactDOM.render</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#React-Diff-算法"><span class="toc-number">5.</span> <span class="toc-text">React Diff 算法</span></a></li></ol><li class="toc-item toc-level-1"><a class="toc-link" href="#参考"><span class="toc-number"></span> <span class="toc-text">参考</span></a></li></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://raw.githubusercontent.com/linxiangjun/ablum/master/blog-img/me.png"></div><div class="author-info__name text-center">linxiangjun</div><div class="author-info__description text-center"></div><div class="follow-button"><a href="https://github.com/linxiangjun">Follow me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">9</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">3</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">3</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://s2.ax1x.com/2019/09/05/nmpXAH.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Code Charm</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="post-info"><div id="post-title">react渲染原理分析</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-06-26</time></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本篇文章作为react源码分析与优化写作计划的第一篇，分析了react是如何创建vdom和fiber tree的。本篇文章通过阅读react 16.8及以上版本源码以及参考大量分析文章写作而成，react框架本身算法以及架构层也是不断的在优化，所以源码中存在很多<code>legacy</code>的方法，不过这并不影响我们对于react设计思想的学习和理解。</p>
<p>阅读源码一定要带着目的性的去展开，这样就会减少过程中的枯燥感，而写作能够提炼和升华自己的学习和理解，这也是本篇以及后续文章的动力所在。如果写作的文章还能够帮助到其他开发者，那就更好了。</p>
<h2 id="JSX"><a href="#JSX" class="headerlink" title="JSX"></a>JSX</h2><p>首先，来看一个简单的 React 组件。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">"App"</span>&gt;</span><br><span class="line">      &lt;h1&gt;Hello React&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面常用的语法称之为 JSX，是 <code>React.createElement</code> 方法的语法糖，使用 JSX 能够直观的展现 UI 及其交互，实现关注点分离。</p>
<p>每个 react 组件的顶部都要导入 React，因为 JSX 实际上依赖 Babel（@babel/preset-react）来对语法进行转换，最终生成<code>React.createElemnt</code>的嵌套语法。</p>
<p>下方能够直观的看到 JSX 转换后的渲染结果。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> React.createElement(</span><br><span class="line">    <span class="string">'div'</span>,</span><br><span class="line">    &#123;</span><br><span class="line">      className: <span class="string">'App'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    React.createElement(<span class="string">'h1'</span>, <span class="literal">null</span>, <span class="string">'Hello React'</span>)</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="createElement"><a href="#createElement" class="headerlink" title="createElement"></a>createElement</h2><p><code>createElement()</code>方法定义如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">React.createElement(type, [props], [...children]);</span><br></pre></td></tr></table></figure>

<p><code>createElement()</code>接收三个参数，分别是元素类型、属性值以及子元素，它最终会生成 Virtual DOM。</p>
<p>我们将上面的<code>&lt;App /&gt;</code>组件内容打印到控制台中。</p>
<p><img src="https://s1.ax1x.com/2020/06/08/th9iFS.png" alt="React Virtual DOM"></p>
<p>可以看到 Virtual DOM 本质上是 JS 对象，将节点信息通过键值对的方式存储起来，同时使用嵌套来表示节点间的层级关系。使用 VDOM 能够避免频繁的进行 DOM 操作，同时也为后面的 React Diff 算法创造了条件。现在回到<code>createElement()</code>方法，来看一下它究竟是如何生产 VDOM 的。</p>
<p><strong>createElement()方法精简版（v16.8）</strong></p>
<p><img src="https://s1.ax1x.com/2020/06/08/thPkKs.png" alt="createElement"></p>
<p>首先，<code>createElement()</code>方法会先通过遍历<code>config</code>获取所有的参数，然后获取其子节点以及默认的<code>props</code>的值。然后将值传递给<code>ReactElement()</code>调用并返回 JS 对象。</p>
<p><img src="https://s1.ax1x.com/2020/06/08/thPivj.png" alt="ReactElement"></p>
<p>值得注意的是，每个 react 组件都会使用<code>$$typeof</code>来标识，它的值使用了<code>Symbol</code>数据结构来确保唯一性。</p>
<h2 id="ReactDOM-render"><a href="#ReactDOM-render" class="headerlink" title="ReactDOM.render"></a>ReactDOM.render</h2><p>到目前为止，我们得到了 VDOM，react通过协调算法（reconciliation）去比较更新前后的VDOM，从而找到需要更新的最小操作，减少了浏览器多次操作DOM的成本。但是，由于使用递归的方式来遍历组件树，当组件树越来越大，递归遍历的成本就越高。这样，由于持续占用主线程，像布局、动画等任务无法立即得到处理，就会出现丢帧的现象。所以，为不同类型的任务赋予优先级，同时支持任务的暂停、中止与恢复，是非常有必要的。</p>
<p>为了解决上面存在的问题，React团队给出了React Fiber算法以及fiber tree数据结构（基于单链表的树结构），而<code>ReactDOM.render</code>方法就是实现React Fiber算法以及构建fiber tree的核心API。</p>
<p><code>render()</code>方法定义如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ReactDOM.render(element, container[, callback])</span><br></pre></td></tr></table></figure>

<p>这里重点从源码层面讲解下<code>ReactDOM.render</code>是如何构建fiber tree的。</p>
<p><code>ReactDOM.render</code>实际调用了<code>legacyRenderSubtreeIntoContainer</code>方法，调用过程以及传参如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ReactDOM = &#123;</span><br><span class="line">  render(element, container, callback) &#123;</span><br><span class="line">    <span class="keyword">return</span> legacyRenderSubtreeIntoContainer(</span><br><span class="line">      <span class="literal">null</span>,</span><br><span class="line">      element,</span><br><span class="line">      container,</span><br><span class="line">      <span class="literal">false</span>,</span><br><span class="line">      callback</span><br><span class="line">    );</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中的<code>element</code>和<code>container</code>我们都很熟悉了，而<code>callback</code>是用来渲染完成后需要执行的回调函数。再来看看该方法的定义。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">legacyRenderSubtreeIntoContainer</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  parentComponent,</span></span></span><br><span class="line"><span class="function"><span class="params">  children,</span></span></span><br><span class="line"><span class="function"><span class="params">  container,</span></span></span><br><span class="line"><span class="function"><span class="params">  forceHydrate,</span></span></span><br><span class="line"><span class="function"><span class="params">  callback</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> root = container._reactRootContainer;</span><br><span class="line">  <span class="keyword">let</span> fiberRoot;</span><br><span class="line">  <span class="comment">// 初次渲染</span></span><br><span class="line">  <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">    <span class="comment">// 初始化挂载，获得React根容器对象</span></span><br><span class="line">    root = container._reactRootContainer = legacyCreateRootFromDOMContainer(</span><br><span class="line">      container,</span><br><span class="line">      forceHydrate</span><br><span class="line">    );</span><br><span class="line">    fiberRoot = root._internalRoot;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化安装不需要批量更新，需要尽快完成</span></span><br><span class="line">    unbatchedUpdates(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      updateContainer(children, fiberRoot, parentComponent, callback);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fiberRoot = root._internalRoot;</span><br><span class="line"></span><br><span class="line">    updateContainer(children, fiberRoot, parentComponent, callback);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> getPublicRootInstance(fiberRoot);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面是简化后的源码。先来看传参，因为是挂载<code>root</code>，所以<code>parentComponent</code>设置为<code>null</code>。另外一个参数<code>forceHydrate</code>代表是否是服务端渲染，因为调用的<code>render()</code>方法为客服端渲染，所以默认为<code>false</code>。另外<code>callback</code>使用少，所以关于它的处理过程就省略了。</p>
<p>因为是首次挂载，所以<code>root</code>从<code>container._reactRootContainer</code>获取不到值，就会创建<code>FiberRoot</code>对象。在<code>FiberRoot</code>对象创建过程中考虑到了服务端渲染的情况，并且函数之间相互调用非常多，所以这里直接展示其最终调用的核心方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建fiberRoot和rootFiber并相互引用</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createFiberRoot</span>(<span class="params">containerInfo, tag, hydrate, hydrationCallbacks</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> root = <span class="keyword">new</span> FiberRootNode(containerInfo, tag, hydrate);</span><br><span class="line">  <span class="keyword">if</span> (enableSuspenseCallback) &#123;</span><br><span class="line">    root.hydrationCallbacks = hydrationCallbacks;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建fiber tree的根节点，即rootFiber</span></span><br><span class="line">  <span class="keyword">const</span> uninitializedFiber = createHostRootFiber(tag);</span><br><span class="line">  root.current = uninitializedFiber;</span><br><span class="line">  uninitializedFiber.stateNode = root;</span><br><span class="line"></span><br><span class="line">  initializeUpdateQueue(uninitializedFiber);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在该方法中<code>containerInfo</code>就是<code>root</code>节点，而<code>tag</code>为<code>FiberRoot</code>节点的标记，这里为<code>LegacyRoot</code>。另外两个参数和服务端渲染有关。这里使用<code>FiberRootNode</code>方法创建了<code>FiberRoot</code>对象，并使用<code>createHostRootFiber</code>方法创建<code>RootFiber</code>对象，使<code>FiberRoot</code>中的<code>current</code>指向<code>RootFiber</code>，<code>RootFiber</code>的<code>stateNode</code>指向<code>FiberRoot</code>，形成相互引用。</p>
<p>下面的两个构造函数是展现出了fiberRoot以及rootFiber的部分重要的属性。</p>
<p>FiberRootNode部分属性:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FiberRootNode</span>(<span class="params">containerInfo, tag, hydrate</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 用于标记fiberRoot的类型</span></span><br><span class="line">  <span class="keyword">this</span>.tag = tag;</span><br><span class="line">  <span class="comment">// 指向当前激活的与之对应的rootFiber节点</span></span><br><span class="line">  <span class="keyword">this</span>.current = <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// 和fiberRoot关联的DOM容器的相关信息</span></span><br><span class="line">  <span class="keyword">this</span>.containerInfo = containerInfo;</span><br><span class="line">  <span class="comment">// 当前的fiberRoot是否处于hydrate模式</span></span><br><span class="line">  <span class="keyword">this</span>.hydrate = hydrate;</span><br><span class="line">  <span class="comment">// 每个fiberRoot实例上都只会维护一个任务，该任务保存在callbackNode属性中</span></span><br><span class="line">  <span class="keyword">this</span>.callbackNode = <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// 当前任务的优先级</span></span><br><span class="line">  <span class="keyword">this</span>.callbackPriority = NoPriority;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Fiber Node构造函数的部分属性:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FiberNode</span>(<span class="params">tag, pendingProps, key, mode</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// rootFiber指向fiberRoot，child fiber指向对应的组件实例</span></span><br><span class="line">  <span class="keyword">this</span>.stateNode = <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// return属性始终指向父节点</span></span><br><span class="line">  <span class="keyword">this</span>.return = <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// child属性始终指向第一个子节点</span></span><br><span class="line">  <span class="keyword">this</span>.child = <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// sibling属性始终指向第一个兄弟节点</span></span><br><span class="line">  <span class="keyword">this</span>.sibling = <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// 表示更新队列，例如在常见的setState操作中，会将需要更新的数据存放到updateQueue队列中用于后续调度</span></span><br><span class="line">  <span class="keyword">this</span>.updateQueue = <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// 表示当前更新任务的过期时间，即在该时间之后更新任务将会被完成</span></span><br><span class="line">  <span class="keyword">this</span>.expirationTime = NoWork;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终生成的fiber tree结构示意图如下：</p>
<p><img src="https://s1.ax1x.com/2020/06/22/NGezqg.png" alt="fiber树结构示意图"></p>
<h2 id="React-Diff-算法"><a href="#React-Diff-算法" class="headerlink" title="React Diff 算法"></a>React Diff 算法</h2><p>react 并不会比原生操作 DOM 快，但是在大型应用中，往往不需要每次全部重新渲染，这时 react 通过 VDOM 以及 diff 算法能够只更新必要的 DOM。react 将 VDOM 与 diff 算法结合起来并对其进行优化，提供了高性能的 React Diff 算法，通过一系列的策略，将传统的 diff 算法复杂度 O(n^3)优化为 O(n)的复杂度，极大的提升了渲染性能。</p>
<p>这里不展开探究 React Diff 的具体实现原理，而先了解下它到底的基于什么策略来实现的。</p>
<ol>
<li>Web UI 中 DOM 节点跨层级的移动操作特别少，可以忽略不计。</li>
<li>拥有相同类的两个组件将会生成相似的树形结构，拥有不同类的两个组件将会生成不同的树形结构。</li>
<li>对于同一层级的一组子节点，它们可以通过唯一 id 进行区分。</li>
</ol>
<p>基于这三个策略，react 在 tree diff 和 component diff 中，两棵树只会对同层次的节点进行比较。如果同层级的树发生了更新，则会将该节点及其子节点同时进行更新，这样避免了递归遍历更加深入的节点的操作。在后面渲染性能优化部分，对于同一类型的组件如果能够准确的知道 VDOM 是否变化，使用<code>shouldComponentUpdate</code>来判断该组件是否需要 diff，能够节省大量的 diff 运算时间。</p>
<p>当 react 进行 element diff 操作中，在元素中添加唯一的<code>key</code>来进行区分，对其进行算法优化。所以像大数据量的列表之类的组件中最好添加<code>key</code>属性，能够带来一定的性能提升。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li>fiber树结构示意图来自<a href="https://juejin.im/post/5e0877486fb9a0165835b80e" target="_blank" rel="noopener">React16源码解读：揭秘ReactDOM.render</a>文章。</li>
</ol>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">linxiangjun</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://www.linxiangjun.com/react-render-source.html">http://www.linxiangjun.com/react-render-source.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/React/">React</a></div><nav id="pagination"><div class="next-post pull-right"><a href="/fibonacci-algorithm.html"><span>从斐波那契数列看两种常用算法和优化</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(https://s2.ax1x.com/2019/09/05/nmpXAH.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2019 - 2020 By linxiangjun</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script>if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
}</script></body></html>