<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Code Charm</title>
  
  <subtitle>代码、诗与远方</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.linxiangjun.com/"/>
  <updated>2019-10-15T02:14:43.237Z</updated>
  <id>http://www.linxiangjun.com/</id>
  
  <author>
    <name>linxiangjun</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>React Hooks技术最佳实践（一）</title>
    <link href="http://www.linxiangjun.com/react-hooks-best-practices-1.html"/>
    <id>http://www.linxiangjun.com/react-hooks-best-practices-1.html</id>
    <published>2019-10-15T02:12:14.000Z</published>
    <updated>2019-10-15T02:14:43.237Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>React 16.8版本发布于2019年2月6号，它带来了Hooks特性，能够让我们不编写class的情况下也能使用state以及其他的React特性。一个新技术的诞生必然会影响原来的思维模式，在最初的应用中也会碰见很多意想不到的场景和陷阱，这就需要我们在使用他们前清楚的知道哪里可能会有潜在的问题，有哪些更加完善的写法，这也是写本文章的初衷。我们团队在7月份开始在新项目中全面使用Hooks技术，期间也遇到和解决了很多的麻烦和问题，同时让我们对于函数式组件有了更深的理解。</p><p>在本文开始前，需要你掌握React官方中关于<a href="https://zh-hans.reactjs.org/docs/hooks-intro.html" target="_blank" rel="noopener">React Hooks</a>的基础知识。很多坑在官方的<a href="https://zh-hans.reactjs.org/docs/hooks-faq.html" target="_blank" rel="noopener">FAQ</a>已经说明了，经常阅读官方文档也是个良好的习惯。</p><p>本文介绍的是我在使用Hooks的过程中遇见的问题和技巧，可能还有其他我没发现的或者没有写出来的，欢迎和我交流，希望通过阅读本文能够让你快速的掌握Hooks的陷阱和技巧，开发出高质量的函数式组件。那我们就先从<code>useState</code>开始。</p><h2 id="useState"><a href="#useState" class="headerlink" title="useState"></a>useState</h2><p>在Class Component中，使用state来存储组件的状态，用<code>setState</code>来更新，在Hooks中提供了<code>useState</code>API来创建一个state。</p><h3 id="state结构"><a href="#state结构" class="headerlink" title="state结构"></a>state结构</h3><p><code>useState</code>接收一个initialState，同时返回一个state以及更新state的函数。initialState可以使用基础数据类型，也可以使用数组、对象等引用数据类型。这里建议根据state的关联度和作用来决定是否使用多个<code>useState</code>来定义state。</p><p>在下面的例子中，我们根据后端接口返回的数据<code>{data: [Tom, Jerry], total: 2, result: true}</code>来设置state数据。第一种写法直接将所有的请求参数和返回数据全部存储到一个<code>userState</code>中，我们来分析下为何不推荐这么做。</p><p>首先，返回的数据中存在不需要存储在state中的数据字段result。其次，将data与requestParams放在一个state中看似简单，只需要维护一个<code>userState</code>，但是如果需要在<code>useEffect</code>中依赖<code>data</code>或者<code>requestParams</code>将会非常的麻烦，而且每次获取后端返回的数据都将需要一同更新<code>requestParams</code>。</p><p><strong>不建议的写法</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [userState, setUserState] = useState(&#123;</span><br><span class="line">    data: [],</span><br><span class="line">    total: <span class="number">0</span>,</span><br><span class="line">    requestParams: &#123; <span class="attr">id</span>: <span class="number">1</span> &#125;,</span><br><span class="line">    result: <span class="literal">true</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>推荐的写法</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [userData, setUserData] = useState(&#123; <span class="attr">data</span>: [], <span class="attr">total</span>: <span class="number">0</span> &#125;)</span><br><span class="line"><span class="keyword">const</span> [userParams, setUserParams] = useState(&#123; <span class="attr">id</span>: <span class="number">1</span> &#125;)</span><br></pre></td></tr></table></figure><h3 id="避免重复计算"><a href="#避免重复计算" class="headerlink" title="避免重复计算"></a>避免重复计算</h3><p>如果initialState为函数，则<code>useState</code>在初始化时会立刻执行该函数和获取函数的返回值，在没有任何返回值得情况下为<code>undefined</code>。这里需要注意的是每次组件re-render都会导致<code>useState</code>中的函数重新计算，这里可以使用闭包函数来解决问题。在优化后只有组件初始化时才会执行一遍<code>loop</code>函数。</p><p>本例子可以在<a href="https://codesandbox.io/s/gracious-stallman-j3zuw?fontsize=14" target="_blank" rel="noopener">CodeSandbox</a>中查看</p><p><strong>优化前</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> loop = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"calc!"</span>);</span><br><span class="line">  <span class="keyword">let</span> res = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = <span class="number">1000</span>; i &lt; len; i++) &#123;</span><br><span class="line">    res += i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> [value, setValue] = useState(loop());</span><br></pre></td></tr></table></figure><p><strong>优化后</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> App = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [value, setValue] = useState(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> loop();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="更新state"><a href="#更新state" class="headerlink" title="更新state"></a>更新state</h3><p>在某些情况下如果需要从上一个state来计算当前的state，可能会想到使用下面优化前的方法。但是，需要注意的一点是在某些闭包的场景下面<code>count</code>可能不是最新的，这样会导致计算错误。这里推荐使用官方给出的方法。</p><p><strong>优化前</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;+&lt;/button&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优化后</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> &lt;button onClick=&#123;() =&gt; setCount(prevCount =&gt; prevCount + 1)&#125;&gt;+&lt;/button&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下一篇文章介绍<code>useEffect</code>和<code>useLayoutEffect</code>的使用技巧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;React 16.8版本发布于2019年2月6号，它带来了Hooks特性，能够让我们不编写class的情况下也能使用state以及其他的Re
      
    
    </summary>
    
      <category term="React" scheme="http://www.linxiangjun.com/categories/React/"/>
    
    
      <category term="React" scheme="http://www.linxiangjun.com/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>Memoization技术在React中的应用</title>
    <link href="http://www.linxiangjun.com/memoization-in-react.html"/>
    <id>http://www.linxiangjun.com/memoization-in-react.html</id>
    <published>2019-09-26T12:35:42.000Z</published>
    <updated>2019-09-26T12:57:30.567Z</updated>
    
    <content type="html"><![CDATA[<p>最近在研究React Hook优化时，发现<strong>Memoization</strong>技术被官方广泛的使用，比如<code>useCallback</code>和<code>useMemo</code>这两个API，分别用来返回函数的memoized版本和memoized值。<strong>Memoization</strong>其实并不是什么新技术，只是一种优化技巧，维基百科对<strong>Memoization</strong>的定义为：</p><blockquote><p>In computing, memoization or memoisation is an optimization technique used primarily to speed up computer programs by storing the results of expensive function calls and returning the cached result when the same inputs occur again.</p></blockquote><p>简单来说<strong>Memoization</strong>就是存储前一个值，然后每次更新时都将新传入的值和存储的值作比较，然后根据比较结果是否相同来返回存储的值还是新的值。React中使用该技术主要是为了避免不必要的重复渲染。</p><h2 id="在Redux中的应用"><a href="#在Redux中的应用" class="headerlink" title="在Redux中的应用"></a>在Redux中的应用</h2><p>我们用来优化Redux数据的<a href="https://github.com/reduxjs/reselect" target="_blank" rel="noopener">reselect</a>其实就使用了Memoization技术，这篇<a href="https://www.linxiangjun.com/2019/09/03/reselect-source-code/#createSelector">文章</a>分析了reselect源码，可以学习reselect是如果使用该技术来优化Redux数据的。</p><h2 id="在React-Hook中的应用"><a href="#在React-Hook中的应用" class="headerlink" title="在React Hook中的应用"></a>在React Hook中的应用</h2><p>熟悉了<strong>Memoization</strong>定义后，我们看下如果在实战中使用这个技术。在React Hook中，<code>useEffect</code>方法可以使用该技术来优化组件的渲染。本例子可以在<a href="https://codesandbox.io/s/useeffect-zkl36?fontsize=14" target="_blank" rel="noopener">CodeSandbox</a>中查看:smile:。</p><p>我们知道<code>useEffect</code>的第二个数组参数作为effect依赖存在，如果依赖数组发生改变，那么<code>useEffect</code>就会重新执行。<code>useEffect</code>使用<code>===</code>来比较数组参数是否相等，使用<code>Object.assign</code>或者<code>splice</code>这类会操作时会返回新的堆来存储引用值，就会导致值本身没有变化却会重复执行<code>useEffect</code>方法。为了避免这种情况的发生，我们来看下该如果来做。</p><p>首先，先来介绍下<code>useRef</code>方法，这个方法和原来的<code>createRef</code>非常的相似，都是创建一个可变的<code>ref</code>对象。在函数组件中，因为<code>ref</code>对象在组件的整个生命周期内保持不变，所以我们可以用它来存储不会被组件re-render影响的值。所以，在下面的函数中，我们使用<code>ref</code>对象来存储<code>useEffect</code>中传入的第二个数组参数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useRef &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; isEqual &#125; <span class="keyword">from</span> <span class="string">"lodash"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useDeepCompareMemoize</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> ref = useRef();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!isEqual(value, ref.current)) &#123;</span><br><span class="line">    ref.current = value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ref.current;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到我使用了lodash中的深比较方法<code>isEqual</code>来对比两个值，这个可以根据需求自定义方法也可以。</p><p>接下来编写自定义Hook来使用<code>useEffect</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useDeepCompareEffect</span>(<span class="params">callback, dependencies</span>) </span>&#123;</span><br><span class="line">  useEffect(callback, useDeepCompareMemoize(dependencies));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> useDeepCompareEffect;</span><br></pre></td></tr></table></figure><p>然后使用<code>useDeepCompareEffect</code>代替<code>useEffect</code>即可。</p><p>使用的完整代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState, useEffect, useRef &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">"react-dom"</span>;</span><br><span class="line"><span class="keyword">import</span> useDeepCompareEffect <span class="keyword">from</span> <span class="string">"./useDeepCompareEffect.js"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"./styles.css"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> tomCat = &#123;</span><br><span class="line">  name: <span class="string">"Tom"</span>,</span><br><span class="line">  race: <span class="string">"cat"</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> jerryMouse = &#123;</span><br><span class="line">  name: <span class="string">"Jerry"</span>,</span><br><span class="line">  race: <span class="string">"mouse"</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [character, updateCharacter] = useState(tomCat);</span><br><span class="line">  <span class="keyword">const</span> effectCount = useRef(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> deepCompareEffectCount = useRef(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    effectCount.current++;</span><br><span class="line">  &#125;, [character]);</span><br><span class="line"></span><br><span class="line">  useDeepCompareEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    deepCompareEffectCount.current++;</span><br><span class="line">  &#125;, [character]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> changeStar = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> star = character.name === <span class="string">"Tom"</span> ? jerryMouse : tomCat;</span><br><span class="line">    updateCharacter(star);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> assignObj = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    updateCharacter(<span class="built_in">Object</span>.assign(&#123;&#125;, character));</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">"App"</span>&gt;</span><br><span class="line">      &lt;p&gt;Hello, useEffect&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;p className="star"&gt;</span></span><br><span class="line"><span class="regexp">        &#123;character.name&#125; &#123;character.race&#125; &#123;character.friend&#125;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>p&gt;</span><br><span class="line">      &lt;p&gt;useEffect count = &#123;effectCount.current&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;p&gt;deepCompareEffectCount count = &#123;deepCompareEffectCount.current&#125;&lt;/</span>p&gt;</span><br><span class="line">      &lt;p&gt;</span><br><span class="line">        &lt;button onClick=&#123;changeStar&#125;&gt;Change star&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>p&gt;</span><br><span class="line">      &lt;p&gt;</span><br><span class="line">        &lt;button onClick=&#123;assignObj&#125;&gt;Click&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>p&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">const rootElement = document.getElementById("root");</span></span><br><span class="line"><span class="regexp">ReactDOM.render(&lt;App /</span>&gt;, rootElement);</span><br></pre></td></tr></table></figure><p>同样的，点击Click按钮，使用<code>useEffect</code>方法每次都会执行，而使用<code>useDeepCompareEffect</code>的只会执行一次。不过需要注意的是，该优化并不是万金油，而是要根据情况来使用。因为深比较本来就会对性能造成一定的损耗，所以要按需使用。比如<code>useCallback</code>和<code>useMemo</code>最好在需要重复计算时才使用，在其他场景应用不当可能会有副作用，关于这一块的内容推荐阅读本文末尾中的参考文章。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://github.com/kentcdodds/use-deep-compare-effect" target="_blank" rel="noopener">use-deep-compare-effect</a></li><li><a href="https://github.com/alexreardon/memoize-one" target="_blank" rel="noopener">memoize-one</a></li><li><a href="https://blog.logrocket.com/rethinking-hooks-memoization/?from=singlemessage&isappinstalled=0" target="_blank" rel="noopener">You’re overusing useMemo: Rethinking Hooks memoization</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近在研究React Hook优化时，发现&lt;strong&gt;Memoization&lt;/strong&gt;技术被官方广泛的使用，比如&lt;code&gt;useCallback&lt;/code&gt;和&lt;code&gt;useMemo&lt;/code&gt;这两个API，分别用来返回函数的memoized版本和mem
      
    
    </summary>
    
      <category term="React" scheme="http://www.linxiangjun.com/categories/React/"/>
    
    
      <category term="React" scheme="http://www.linxiangjun.com/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>使用React Hook实现Redux状态机</title>
    <link href="http://www.linxiangjun.com/react-hook-acheieve-redux.html"/>
    <id>http://www.linxiangjun.com/react-hook-acheieve-redux.html</id>
    <published>2019-09-13T10:59:48.000Z</published>
    <updated>2019-09-13T11:05:54.968Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Redux is a predictable state container for JavaScript apps.</p></blockquote><p>本文的代码可以在<a href="https://codesandbox.io/embed/usereducer-4w77g" target="_blank" rel="noopener">CodeSandbox</a>中查看。</p><p>Redux是React经常用到的一个数据状态管理器（状态机），它将应用中所有的数据（state）以对象树的形式存储在<em>store</em>中，通过触发<em>action</em>来改变<em>state</em>，而描绘改变规则需要编写<em>reducer</em>。</p><p>因为Redux不仅仅是为React编写的，所以在React中常常会用到<a href="https://github.com/reduxjs/react-redux" target="_blank" rel="noopener">React-Redux</a>来一同使用。React-Redux使用两个主要的API，分为叫做<code>Provider</code>和<code>connect</code>来提升Redux开发效率和体验。</p><p>在React 16.8之前，为了实现统一的状态机，最好的方法就是使用Redux了。不过，React 16.8中Hook API新增的<code>useContext</code>和<code>useReducer</code>能够让我们自己实现一个具备Redux核心功能的状态机。</p><p>我们先看一下Redux的<a href="https://redux.js.org/introduction/three-principles" target="_blank" rel="noopener">三个基本原则</a>是什么：</p><ol><li><strong>单一数据源</strong> - 整个应用程序的state存储在单个store的对象树中</li><li><strong>state为只读</strong> - 改变state的唯一方法是触发一个action</li><li><strong>使用纯函数来修改</strong> - 为了描述actions是如何修改state，你需要编写reducers</li></ol><p>我们遵循这三个基本原则来开发我们自己的状态机，其实查看<code>useReducer</code>的用法就知道它已经满足了原则2和3</p><p><code>const [state, dispatch] = useReducer(reducer, initialArg, init);</code></p><p>所以，我们结合官网的<a href="https://zh-hans.reactjs.org/docs/hooks-reference.html#usereducer" target="_blank" rel="noopener">例子</a>来编写<em>state</em>和<em>reducer</em>。</p><p>文件目录如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public</span><br><span class="line">src</span><br><span class="line">  reducer</span><br><span class="line">    index.js</span><br><span class="line">  index.js</span><br><span class="line">  style.css</span><br><span class="line">package.json</span><br></pre></td></tr></table></figure><p>在reducer文件夹的index.js文件中，编写<code>initialState</code>和<code>reducer</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> initialState = &#123; <span class="attr">count</span>: <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">reducer</span>(<span class="params">state, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"increment"</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">count</span>: state.count + <span class="number">1</span> &#125;;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"decrement"</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">count</span>: state.count - <span class="number">1</span> &#125;;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在src/index.js中生成一个<code>store</code>，只在顶层组件中创建一个<code>store</code>是为了符合原则1。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; reducer, initialState &#125; <span class="keyword">from</span> <span class="string">"./reducer"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = useReducer(reducer, initialState);</span><br></pre></td></tr></table></figure><p>可以看到应用<code>useReducer</code>很简单的就创建了一个符合Redux三个基本原则的状态机，然后我们就要考虑如何将store状态传递到更深层次的组件中。在Redux中我们使用<code>subscribe</code>方法去订阅状态，而使用React-Redux可以将<code>store</code>像props一样传值给子组件，这样就不需要每次都去订阅。所以，接下来我们使用React中的<a href="https://zh-hans.reactjs.org/docs/context.html" target="_blank" rel="noopener">Context</a> API来实现状态的传递。</p><p>在src/index.js中创建一个<code>AppContext</code>，初始值为空：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> AppContext = createContext(&#123;&#125;);</span><br><span class="line"><span class="keyword">const</span> &#123; Provider &#125; = AppContext;</span><br></pre></td></tr></table></figure><p>然后在顶层组件<code>App</code>中使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> store = useReducer(reducer, initialState);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Provider value=&#123;store&#125;&gt;</span><br><span class="line">      &lt;div className=<span class="string">"App"</span>&gt;</span><br><span class="line">        &lt;TopNavBar /&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>Provider&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样无论多深的组件都能够获取到<code>store</code>存储的数据状态，而且能够获取到<code>dispatch</code>方法来改变<code>state</code>。这里React的另一个Hook就要发挥实力了，那就是<code>useContext</code>，它可以接收一个context对象（React.createContext的返回值）并返回该context的当前值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">TopNavBar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> value = useContext(AppContext);</span><br><span class="line">  <span class="keyword">const</span> [state] = value; <span class="comment">// 这里的value就是useReducer创建的store</span></span><br><span class="line">  <span class="keyword">const</span> &#123; count &#125; = state;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;p&gt;&#123;count&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;Button /</span>&gt;</span><br><span class="line">    &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>在<code>Button</code>组件中使用<code>useContext</code>获取<code>dispatch</code>来通过触发一个<code>action</code>来改变<code>count</code>的值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Button</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> value = useContext(AppContext);</span><br><span class="line">  <span class="keyword">const</span> [state, dispatch] = value;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">"button-wrapper"</span>&gt;</span><br><span class="line">      &lt;button type=<span class="string">"button"</span> onClick=&#123;() =&gt; dispatch(&#123; <span class="attr">type</span>: <span class="string">"increment"</span> &#125;)&#125;&gt;</span><br><span class="line">        Plus</span><br><span class="line">      &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button type="button" onClick=&#123;() =&gt; dispatch(&#123; type: "decrement" &#125;)&#125;&gt;</span></span><br><span class="line"><span class="regexp">        Minus</span></span><br><span class="line"><span class="regexp">      &lt;/</span>button&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>这样一个满足Redux的三个原则，同时具备React-Redux部分功能的简洁版状态机就完成了。在一些不需要管理过多复杂状态的应用中我们就可以使用这样的方式来自己创建状态机，当然，我们还有像<em>effect</em>、<em>connect</em>和<em>middleware</em>这样的功能没有完全实现，但是在准备使用他们之前，先得思考以下，是否真的需要。</p><blockquote><p>Brevity is the soul of wisdom. Tediousness is the limbs and outward flourishes.</p><p>—— William Shakespeare</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;Redux is a predictable state container for JavaScript apps.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本文的代码可以在&lt;a href=&quot;https://codesandbox.io/emb
      
    
    </summary>
    
      <category term="React" scheme="http://www.linxiangjun.com/categories/React/"/>
    
    
      <category term="React" scheme="http://www.linxiangjun.com/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>Reselect源码解析</title>
    <link href="http://www.linxiangjun.com/reselect-source-code.html"/>
    <id>http://www.linxiangjun.com/reselect-source-code.html</id>
    <published>2019-09-03T13:42:46.000Z</published>
    <updated>2019-09-05T11:43:26.944Z</updated>
    
    <content type="html"><![CDATA[<p>Reselect主要为Redux的state数据提供了Memoize功能。它能够计算数据，传递最少且必要的state值；具有高性能，只在传递值改变时才会重新计算；具有可组合性，可以将它作为参数传递给其他selectors执行。</p><p>下面是个最基础的使用方式，可以跳转<a href="https://codepen.io/linxiangjun/pen/rNBGKNd?editors=0012" target="_blank" rel="noopener">codepen</a>来运行栗子</p><img src="/reselect-source-code/Reselect-20190903001.png" title="基础用法"><h2 id="createSelector"><a href="#createSelector" class="headerlink" title="createSelector"></a>createSelector</h2><p><code>createSelector</code>方法是Reselect的核心方法，最后一个参数默认为回调函数，其他参数可以为state、selector或数组，其中回调函数会引用其他参数作为自己的参数调用。</p><p><code>createSelector</code>实际上调用的是Reselect中叫做<code>createSelectorCreator</code>的API，该API允许我们开发定制版本的<code>createSelector</code>。</p><p><code>createSelectorCreator</code>被调用时会引用默认的Memoize方法来校验输入数据，在源码中叫做<code>defaultMemoize</code>，该方法返回的函数就是用来判断是直接返回已经记忆的计算结果还是重新计算并返回新的结果。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// func就是createSelector参数中最后一个函数参数</span></span><br><span class="line"><span class="comment">// equalityCheck参数默认获取defaultEqualityCheck方法</span></span><br><span class="line"><span class="comment">// defaultEqualityCheck代码就是判断是否全等的函数：(a, b) =&gt; a === b</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">defaultMemoize</span>(<span class="params">func, equalityCheck = defaultEqualityCheck</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> lastArgs = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">let</span> lastResult = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 比较旧的和新的state是否全等</span></span><br><span class="line">    <span class="comment">// 如果不相等，则重新计算并将结果赋值给lastResult</span></span><br><span class="line">    <span class="keyword">if</span> (!areArgumentsShallowlyEqual(equalityCheck, lastArgs, <span class="built_in">arguments</span>)) &#123;</span><br><span class="line">      lastResult = func.apply(<span class="literal">null</span>, <span class="built_in">arguments</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    lastArgs = <span class="built_in">arguments</span></span><br><span class="line">    <span class="keyword">return</span> lastResult</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中的<code>areArgumentsShallowlyEqual</code>方法思路很简洁，使用for循环依次比较传入的两个数组中的每一个值是否全等。</p><p>我们接下来看一下<code>createSelectorCreator</code>的代码是如何使用<code>defaultMemoize</code>的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// memoize默认为上面介绍的defaultMemoize</span></span><br><span class="line"><span class="comment">// memoizeOptions作为memoize方法的引用参数</span></span><br><span class="line"><span class="comment">// 如果没有传值则默认为equalityCheck = defaultEqualityCheck</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createSelectorCreator</span>(<span class="params">memoize, ...memoizeOptions</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">...funcs</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 统计计算次数</span></span><br><span class="line">    <span class="keyword">let</span> recomputations = <span class="number">0</span></span><br><span class="line">    <span class="comment">// 获取selector参数中的最后一个回调函数</span></span><br><span class="line">    <span class="keyword">const</span> resultFunc = funcs.pop()</span><br><span class="line">    <span class="comment">// getDependencies函数获取其余的参数 先判断第一个参数是否为数组</span></span><br><span class="line">    <span class="comment">// 如果是则返回第一个数组 否则直接返回</span></span><br><span class="line">    <span class="comment">// 注意：参数中具体的项必须为函数类型，否则会抛出一个错误</span></span><br><span class="line">    <span class="keyword">const</span> dependencies = getDependencies(funcs)</span><br><span class="line">    <span class="comment">// 根据传入的arguments来判断是否重新计算结果</span></span><br><span class="line">    <span class="keyword">const</span> memoizedResultFunc = memoize(</span><br><span class="line">      <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        recomputations++</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> resultFunc.apply(<span class="literal">null</span>, <span class="built_in">arguments</span>)</span><br><span class="line">      &#125;,</span><br><span class="line">      ...memoizeOptions</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据传入的state是否改变来判断需不需要执行下面代码</span></span><br><span class="line">    <span class="keyword">const</span> selector = memoize(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">const</span> params = []</span><br><span class="line">      <span class="keyword">const</span> length = dependencies.length</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        params.push(dependencies[i].apply(<span class="literal">null</span>, <span class="built_in">arguments</span>))</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> memoizedResultFunc.apply(<span class="literal">null</span>, params)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    selector.resultFunc = resultFunc</span><br><span class="line">    selector.dependencies = dependencies</span><br><span class="line">    selector.recomputations = <span class="function"><span class="params">()</span> =&gt;</span> recomputations</span><br><span class="line">    selector.resetRecomputations = <span class="function"><span class="params">()</span> =&gt;</span> recomputations = <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> selector</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Reselect的源码很精简，阅读后能够提升对于Memoization和React优化的理解。作者在注释中多次说明使用<code>for</code>代替<code>forEach</code>和<code>every</code>，使用<code>arguments</code>而不是展开运算符是为了更快和提高性能。Reselect的官方文档阅读起来也非常的清晰和轻松，对于常见问题的解答也是很全面，这点要点赞。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Reselect主要为Redux的state数据提供了Memoize功能。它能够计算数据，传递最少且必要的state值；具有高性能，只在传递值改变时才会重新计算；具有可组合性，可以将它作为参数传递给其他selectors执行。&lt;/p&gt;
&lt;p&gt;下面是个最基础的使用方式，可以跳
      
    
    </summary>
    
      <category term="源码系列" scheme="http://www.linxiangjun.com/categories/%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="源码系列" scheme="http://www.linxiangjun.com/tags/%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
</feed>
